# Algorithm Design Project

This repository contains a set of C++ implementations for various classic algorithms. These algorithms are essential in the fields of computer science and operations research, covering topics such as sorting, searching, graph theory, dynamic programming, and more.

## Table of Contents

1. [Merge Sort](#1-merge-sort)
2. [Quick Sort](#2-quick-sort)
3. [Binary Search](#3-binary-search)
4. [Arithmetic with Large Integers](#4-arithmetic-with-large-integers)
5. [Chained Matrix Multiplication](#5-chained-matrix-multiplication)
6. [Longest Common Subsequence (LCS)](#6-longest-common-subsequence-lcs)
7. [Optimal Binary Search Tree (BST)](#7-optimal-binary-search-tree-bst)
8. [Floyd-Warshall Algorithm](#8-floyd-warshall-algorithm)
9. [Fractional Knapsack](#9-fractional-knapsack)
10. [Dijkstra's Algorithm](#10-dijkstras-algorithm)
11. [Huffman Coding](#11-huffman-coding)
12. [0/1 Knapsack](#12-01-knapsack)
13. [0/1 Knapsack (Backtracking)](#13-01-knapsack-backtracking)
14. [Sum of Subsets](#14-sum-of-subsets)
15. [N-Queens Problem](#15-n-queens-problem)
16. [Graph Coloring](#16-graph-coloring)
17. [8-Puzzle Problem](#17-8-puzzle-problem)
18. [15-Puzzle Problem](#18-15-puzzle-problem)

## 1. Merge Sort

Merge Sort is a divide-and-conquer algorithm that sorts an array by recursively dividing it into two halves, sorting each half, and then merging the sorted halves.

## 2. Quick Sort

Quick Sort is an efficient sorting algorithm that uses a pivot element to partition the array into two sub-arrays, which are then sorted independently.

**Watch the video**: https://www.aparat.com/v/r66b76p

## 3. Binary Search

Binary Search is a fast algorithm for finding a target value within a sorted array. It repeatedly divides the search interval in half until the target value is found or the interval is empty.

**Watch the video**: https://www.aparat.com/v/s33s8o6

## 4. Arithmetic with Large Integers

This algorithm handles arithmetic operations on large integers that cannot be accommodated by the standard data types in C++. It includes addition, subtraction, multiplication, and division.

## 5. Chained Matrix Multiplication

This algorithm finds the most efficient way to multiply a given sequence of matrices. The problem is solved using dynamic programming to minimize the number of scalar multiplications.

## 6. Longest Common Subsequence (LCS)

The LCS algorithm finds the longest subsequence present in both given sequences. It is useful in DNA sequencing, text comparison, and other applications.

**Watch the video**: https://www.aparat.com/v/Prdge

## 7. Optimal Binary Search Tree (BST)

This algorithm constructs an optimal binary search tree from a given set of keys, minimizing the expected search cost based on the frequency of each key.

**Watch the video**: https://www.aparat.com/v/t36jf4h

## 8. Floyd-Warshall Algorithm

The Floyd-Warshall algorithm finds the shortest paths between all pairs of vertices in a weighted graph. It is useful for solving the all-pairs shortest path problem.

## 9. Fractional Knapsack

The Fractional Knapsack algorithm solves the knapsack problem where items can be broken into smaller pieces. It uses a greedy approach to maximize the total value in the knapsack.

**Watch the video**: https://www.aparat.com/v/kPeMb

## 10. Dijkstra's Algorithm

Dijkstra's Algorithm finds the shortest path from a single source vertex to all other vertices in a weighted graph. It is widely used in network routing and mapping applications.

**Watch the video**: https://www.aparat.com/v/a1586a4

## 11. Huffman Coding

Huffman Coding is a compression algorithm that builds an optimal prefix code based on the frequency of each character. It is used in data compression applications.

## 12. 0/1 Knapsack

The 0/1 Knapsack algorithm solves the problem of selecting items with given weights and values to maximize the total value without exceeding the weight capacity. Items cannot be broken down.

## 13. 0/1 Knapsack (Backtracking)

This is a backtracking approach to solving the 0/1 Knapsack problem. It explores all possible subsets to find the optimal solution.

## 14. Sum of Subsets

The Sum of Subsets algorithm finds all subsets of a given set whose sum is equal to a given target value. It uses a backtracking approach to explore all possible subsets.

## 15. N-Queens Problem

The N-Queens problem involves placing N chess queens on an N×N chessboard so that no two queens threaten each other. This algorithm uses backtracking to find all possible solutions.

**Watch the video**: https://www.aparat.com/v/r43m965

## 16. Graph Coloring

Graph Coloring is the problem of assigning colors to the vertices of a graph so that no two adjacent vertices share the same color. It is solved using a backtracking approach.

**Watch the video**: https://www.aparat.com/v/v929x1v

## 17. 8-Puzzle Problem

The 8-Puzzle problem is a sliding puzzle that consists of a 3×3 grid with 8 numbered tiles and one blank space. The goal is to arrange the tiles in a specific order using the blank space.

## 18. 15-Puzzle Problem

The 15-Puzzle problem is a sliding puzzle that consists of a 4×4 grid with 15 numbered tiles and one blank space. The goal is to arrange the tiles in a specific order using the blank space.

## Getting Started

To compile and run the program, you need a C++ compiler installed on your system.

1. **Clone the repository:**
   ```bash
   git clone https://github.com/Kiana8181/Algorithm-Design-Project.git
   
2. Compile the program

3. Run the program
